====== 正则表达式 ======

正则表达式由原子(普通字符)、元字符(特殊功用的字符)以及模式修正符组成，其中至少包含一个原子。

===== 元字符 =====

元字符用来描述其前面的字符在匹配模式中出现的方式。元字符本身是一个单一的字符，不同或者相同的元字符组合起来可以构成大的元字符。
  ()  将不同的字符串组成一组，也称为原子
  []  定义字符集合，即原子表
  {}  指定重复次数
  ^   在字符串的开始匹配或者表示不在某个字符集合内
  $   在字符串的结尾匹配
  .   匹配除换行符(\n)之外的任意字符
  ?   重复零次或者一次
  *   重复零次或者多次
  +   重复一次或者多次
  \   转义字符
  |   或者，选择分支的标识
构造正则表达式的方法和创建数学表达式的方法相似，就是用多种元字符与操作符将小的表达式结合在一起创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。元字符是组成正则表达式的最重要的元素。

===== 原子表 =====

原子是组成正则表达戒指基本单位，在分析正则表达式时，应作为一个整体。一组原子可以存放在原子表[]中，彼此地位相等，且仅匹配其中一个原子。

原子表表达式可以用来定义一个原子集合，其含义是必须匹配该集合中的任意一个字字符。有两种表达方式：
  - 把所有的字符都列举出来。如，[0123456789]可以与任何数字字符相匹配，但是只能匹配一个字符。
  - 利用字符'-'来表示字符区间。如上列，可表示为[0-9]。
通常情况下，字符'-'都只表示一个普通字符，只有在表示范围时才被作为元字符来使用。如，[-0-9],第一个'-'只代表一个普通字符，而第二个'-'是一个元字符，用来表示数字字符0-9的范围。一些常用的原子表表达式：
  [a-z]    小写字母字符
  [A-Z]    大写字母字符
  [a-zA-Z] 大小写字母字符
  [0-9]    数字字符

===== 定位符 =====

定位符是用来描述字符串或单词的边界的，具体包括'^'和'$'，它们的含义分别为在字符串的开始匹配和在字符串的结尾匹配。

元字符'^'如果出现在方括号表达式中，则表示的含义为否；如果出现在方括号表达式外面，则表示的含义为字符串的开始。例如，'^[^0-9][0-9]$'可以用来校验两个字符组成的字符串，并且该字符串要同时满足前面的字符不能为数字字符、后面的字符必须是数字字符。

===== 量词 =====

量词也被称为限定符，用来指定字符必须出现的次数，也就是说在指定一个重复模式时要使用量词。
  *      重复任意次数（包括零次）
  +      重复一次或多次
  ？     重复零次或一次
  {n}    重复n次，其中n是一个非负整数
  {n,}   重复至少n次
  {m, n} 重复至少m~n次
注意：量词'?'如果出现在方括号表达式中，则只是代表一个普通的字符。例如，'[-a-z?]'可以用来校验任何一个字母字符，或者一个普通字符'?'或'-'。

===== 选择符 =====

竖线'|'可以表示选择分支。例如：
  'YYYY-MM-DD'格式的日期： ^([0-9]{4})-([0-9]{1,2})-([0-9]{1，2})$
  IP地址：    ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$
  英文字符串： [A-Za-z]+

===== 转义字符 =====

  \d    匹配一个数字，等价于[0-9]
  \D    匹配除数字以外的任何一个字符，等价于[^0-9]
  \w    匹配一个英文字母、数字或下划线，等价于[0-9a-zA-Z]
  \W    匹配除英文字母、数字和下划线以外的任何一个字符，等价于[^0-9a-zA-Z]
  \s    匹配一个空白字符，等价于[\f\n\r\t\v]
  \S    匹配除空白字符以外任何一个字符，等价于[^\f\n\r\t\v]
  \f    匹配一个换页符，等价于\x0c或\cl
  \n    匹配一个换行符，等价于\x0a或\cJ
  \r    匹配一个回车符，等价于\x0d或\cM
  \t    匹配一个制表符，等价于\x09或\cl
  \v    匹配一个垂直制表符，等价于\x0b或\ck
  \oNN  匹配一个八进制数字
  \xNN  匹配一个十六进制数字
  \cC   匹配一个控制字符
常用正则表达式：
  Email: ^[a-zA-Z0-9_.]+@[a-zA-Z0-9_]+[.a-zA-Z0-9_]+$
  http网址：^http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w-.\/?%&=]*)?$

===== POSIX风格 =====

POSIX全称是可移植操作系统接口。POSIX正则表达式在使用时需要遵循一些标准，这样做的优点是在大多数环境下正则表达式都可使用。

==== 字符簇 ====
  [[:alnum:]]  字母字符和数字
  [[:alpha:]]  字母
  [[:upper:]]  大写字母
  [[:lower:]]  小写字母
  [[:digit:]]  数字
  [[:blank:]]  空格符和制表符
  [[:space:]]  空白字符包括空格
  [[:print:]]  可打印字符
  [[:ascii:]]  7位ASCII码

==== 正则表达式函数 ====

1. ereg():查找匹配的子串
  int ereg( string $pattern, string $str [, array &$regs] )
$regs:用来存放匹配的结果，其中，regs[0]为原字符串；regs[1]为第一个符合匹配规则的字符串，以此类推。ereg()，大小写敏感。eregi(),大小写不敏感。

2.查找和替换子字符串，与str_replace()实现的功能相同。
  string ereg_replace( string $pattern, string $replacement, string $str )
ereg_replace()对大小写敏感。ereg_replacei()函数对大小写不敏感。

3.拆分字符串
  array split( string $pattern, string $str [, int $limit] )
$limit: 指定将字符串$str切分的最大数目。默认值为-1，表示没有限制。该函数对大小写敏感，spliti()不区分大小写。

4.将字符串中的字符逐字返回大小写。
  string sql_regcase( string $str )

===== Perl风格 =====

与POSIX正则表达式不同，Perl正则表达式需要以分隔符作为开始和结束标识。

==== 修饰符 ====

在Perl正则表达式中的最后一个分隔符后，可以添加一个修饰符来更改正则表达式的行为。
  * I  表示在字符串中不区分大小写。
  * M  多行模式，相当于第一行的开头都是^，结尾都是$。
  * S  '.'将校验所有字符，包括换行符。没有它，换行符则被排除在外。
  * X  空格将会被全部忽略，除非用转义符或者一个字符的内部类型，还有所有字符类型外的未转义的'#'号之间的空格也被忽略。
  * D  '$'修饰符将仅匹配目标字符串里的尾部。没有这个修饰符，'$'字符也匹配新行的尾部，如果设置了M修饰符则忽略这个修饰符。
  * U  匹配这第一次就会立即停止操作。

==== 字符簇 ====

Perl字符簇，不仅支持POSIX字符簇，还定义了一些其特有的字符簇。
  \d  数字
  \D  非数字字符
  \s  空白符
  \S  非空白符
  \w  字母、数字、下划线
  \W  非字母、数字、下划线

==== 正则表达式函数 ====
Perl正则表达式，分隔符都是'/'，可出现在双引号内正则表达式的开始和结尾处，此分隔符并非正则表达式的一部分。

=== preg_grep() ===
preg_grep()将返回一个数组，如要存在一个较大的值集，并需要对其进行搜索以查找匹配项，该方法非常有效。
  array preg_grep( string $pattern, array $input [, int $flags] )
$flags: 如果设置该参数值为preg_grep_invert，那么该函数将会返回输入数组中不匹配给定$pattern模式的所有值，该参数的默认值为零。

=== preg_split() ===
preg_split()使用正则表达式分割字符串，并将结果以数组的形式返回。
  array preg_split( string $pattern, string $subject [, int $limit [, int $flags]] )
$limit: 指定可以将字符串$subject切分的最大目标数，默认值为-1，表示没有限制。$flags: 可以取两值，当其值为preg_split_no_empty时，表示空值，将不会被返回；当其值为preg_split_offset_capture时，返回一个二维数组，对于每个出现的匹配结果在返回其结果值的同时返回其所在的位置。

=== preg_match() ===
preg_match()用于在字符串中查找匹配项，并返回一个数组，其中包含通过正则表达式在其中找到匹配项的另外一个数组的全部项目。
  int preg_match( string $pattern, string $subject [, array $matches [, int $flags]] )
$matches: 用来存放匹配结果，其中matches[0]为原字符串，matches[1]为第一个符合匹配规则的字符串，以此类推。$flags：如果设置该参数值为preg_offset_capture,那么preg_match()将在返回每个出现的匹配结果的同时返回该匹配结果的字符串中的位置。

=== preg_replace() ===

preg_replace()用来查找和替换子字符串。
  mixed preg_replace( mixed $pattern, mixed $replacement, mixed $subject[, int $limit] )
$limit: 指定需要进行替换的字符串的个数，默认值为-1，表示所有的匹配项都会被替换。

=== preg_quote() ===

preg_quote()在每个正则表达式的特殊字符前面加入一个转义字符，也就是'\'。
  string preg_quote( string $string [, string $delimiter] )
$delimiter: 默认值为null，如果设置该参数，那么设置的值也将被转义。



